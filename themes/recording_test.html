<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å½•éŸ³åŠŸèƒ½å…¼å®¹æ€§æµ‹è¯•</title>
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .test-item {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .test-item.pass {
            border-color: #4CAF50;
            background-color: #f8fff8;
        }

        .test-item.fail {
            border-color: #f44336;
            background-color: #fff8f8;
        }

        .status {
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            color: white;
            min-width: 60px;
            text-align: center;
        }

        .status.pass {
            background-color: #4CAF50;
        }

        .status.fail {
            background-color: #f44336;
        }

        .status.testing {
            background-color: #ff9800;
        }

        .record-test {
            text-align: center;
            margin: 30px 0;
        }

        .record-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px;
        }

        .record-button:hover {
            transform: scale(1.1);
        }

        .record-button.recording {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .log {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .suggestions {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ å½•éŸ³åŠŸèƒ½å…¼å®¹æ€§æµ‹è¯•</h1>
        
        <div id="tests">
            <div class="test-item" id="test-https">
                <span>HTTPSåè®®æ£€æŸ¥</span>
                <span class="status testing">æ£€æµ‹ä¸­</span>
            </div>
            
            <div class="test-item" id="test-mediadevices">
                <span>MediaDevices APIæ”¯æŒ</span>
                <span class="status testing">æ£€æµ‹ä¸­</span>
            </div>
            
            <div class="test-item" id="test-mediarecorder">
                <span>MediaRecorder APIæ”¯æŒ</span>
                <span class="status testing">æ£€æµ‹ä¸­</span>
            </div>
            
            <div class="test-item" id="test-permission">
                <span>éº¦å…‹é£æƒé™çŠ¶æ€</span>
                <span class="status testing">æ£€æµ‹ä¸­</span>
            </div>
            
            <div class="test-item" id="test-formats">
                <span>æ”¯æŒçš„éŸ³é¢‘æ ¼å¼</span>
                <span class="status testing">æ£€æµ‹ä¸­</span>
            </div>
        </div>

        <div class="record-test">
            <h3>å½•éŸ³åŠŸèƒ½æµ‹è¯•</h3>
            <button id="recordBtn" class="record-button">ğŸ¤</button>
            <div id="recordStatus">ç‚¹å‡»éº¦å…‹é£å¼€å§‹æµ‹è¯•å½•éŸ³</div>
        </div>

        <div class="log" id="log"></div>

        <div class="suggestions" id="suggestions" style="display: none;">
            <h4>ğŸ”§ å»ºè®®è§£å†³æ–¹æ¡ˆï¼š</h4>
            <ul id="suggestionsList"></ul>
        </div>
    </div>

    <script>
        class RecordingTester {
            constructor() {
                this.logs = [];
                this.suggestions = [];
                this.mediaRecorder = null;
                this.isRecording = false;
                
                this.init();
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.logs.push(`[${timestamp}] ${message}`);
                document.getElementById('log').innerHTML = this.logs.join('<br>');
                console.log(message);
            }

            addSuggestion(suggestion) {
                this.suggestions.push(suggestion);
                this.updateSuggestions();
            }

            updateSuggestions() {
                const suggestionsDiv = document.getElementById('suggestions');
                const suggestionsList = document.getElementById('suggestionsList');
                
                if (this.suggestions.length > 0) {
                    suggestionsDiv.style.display = 'block';
                    suggestionsList.innerHTML = this.suggestions.map(s => `<li>${s}</li>`).join('');
                }
            }

            updateTestStatus(testId, status, details = '') {
                const testItem = document.getElementById(testId);
                const statusSpan = testItem.querySelector('.status');
                
                testItem.className = `test-item ${status}`;
                statusSpan.className = `status ${status}`;
                statusSpan.textContent = status === 'pass' ? 'âœ“ é€šè¿‡' : status === 'fail' ? 'âœ— å¤±è´¥' : 'æ£€æµ‹ä¸­';
                
                if (details) {
                    testItem.querySelector('span:first-child').textContent += ` (${details})`;
                }
            }

            async init() {
                this.log('å¼€å§‹å½•éŸ³å…¼å®¹æ€§æµ‹è¯•...');
                
                // æµ‹è¯•HTTPS
                this.testHTTPS();
                
                // æµ‹è¯•MediaDevices API
                this.testMediaDevices();
                
                // æµ‹è¯•MediaRecorder API
                this.testMediaRecorder();
                
                // æµ‹è¯•æƒé™
                await this.testPermission();
                
                // æµ‹è¯•éŸ³é¢‘æ ¼å¼
                this.testAudioFormats();
                
                // ç»‘å®šå½•éŸ³æµ‹è¯•
                this.bindRecordingTest();
            }

            testHTTPS() {
                const isSecure = window.isSecureContext || 
                               location.hostname === 'localhost' || 
                               location.hostname === '127.0.0.1' ||
                               location.protocol === 'https:';
                
                if (isSecure) {
                    this.updateTestStatus('test-https', 'pass');
                    this.log('HTTPSæ£€æŸ¥é€šè¿‡');
                } else {
                    this.updateTestStatus('test-https', 'fail');
                    this.log('HTTPSæ£€æŸ¥å¤±è´¥ï¼šéœ€è¦HTTPSåè®®');
                    this.addSuggestion('ç¡®ä¿ç½‘ç«™ä½¿ç”¨HTTPSåè®®è®¿é—®');
                }
            }

            testMediaDevices() {
                if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
                    this.updateTestStatus('test-mediadevices', 'pass');
                    this.log('MediaDevices APIæ”¯æŒæ£€æŸ¥é€šè¿‡');
                } else {
                    this.updateTestStatus('test-mediadevices', 'fail');
                    this.log('MediaDevices APIä¸æ”¯æŒ');
                    this.addSuggestion('æ›´æ–°æµè§ˆå™¨åˆ°æ”¯æŒMediaDevices APIçš„ç‰ˆæœ¬');
                }
            }

            testMediaRecorder() {
                if (typeof window.MediaRecorder !== 'undefined') {
                    this.updateTestStatus('test-mediarecorder', 'pass');
                    this.log('MediaRecorder APIæ”¯æŒæ£€æŸ¥é€šè¿‡');
                } else {
                    this.updateTestStatus('test-mediarecorder', 'fail');
                    this.log('MediaRecorder APIä¸æ”¯æŒ');
                    this.addSuggestion('æ›´æ–°æµè§ˆå™¨åˆ°æ”¯æŒMediaRecorder APIçš„ç‰ˆæœ¬');
                }
            }

            async testPermission() {
                try {
                    if (navigator.permissions) {
                        const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
                        this.log(`éº¦å…‹é£æƒé™çŠ¶æ€: ${permissionStatus.state}`);
                        
                        if (permissionStatus.state === 'granted') {
                            this.updateTestStatus('test-permission', 'pass', 'å·²æˆæƒ');
                        } else if (permissionStatus.state === 'denied') {
                            this.updateTestStatus('test-permission', 'fail', 'è¢«æ‹’ç»');
                            this.addSuggestion('åœ¨æµè§ˆå™¨åœ°å€æ ç‚¹å‡»é”å›¾æ ‡ï¼Œå…è®¸éº¦å…‹é£æƒé™');
                        } else {
                            this.updateTestStatus('test-permission', 'testing', 'éœ€è¦ç”¨æˆ·æˆæƒ');
                            this.log('æƒé™çŠ¶æ€ä¸ºpromptï¼Œéœ€è¦ç”¨æˆ·ä¸»åŠ¨æˆæƒ');
                        }
                    } else {
                        this.updateTestStatus('test-permission', 'testing', 'æ— æ³•æŸ¥è¯¢');
                        this.log('æµè§ˆå™¨ä¸æ”¯æŒæƒé™æŸ¥è¯¢API');
                    }
                } catch (error) {
                    this.updateTestStatus('test-permission', 'testing', 'æŸ¥è¯¢å¤±è´¥');
                    this.log(`æƒé™æŸ¥è¯¢å¤±è´¥: ${error.message}`);
                }
            }

            testAudioFormats() {
                const formats = [
                    'audio/webm;codecs=opus',
                    'audio/mp4',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/wav'
                ];

                const supportedFormats = formats.filter(format => 
                    MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(format)
                );

                if (supportedFormats.length > 0) {
                    this.updateTestStatus('test-formats', 'pass', `${supportedFormats.length}ç§æ ¼å¼`);
                    this.log(`æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ${supportedFormats.join(', ')}`);
                } else {
                    this.updateTestStatus('test-formats', 'fail', 'æ— æ”¯æŒæ ¼å¼');
                    this.log('æ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„éŸ³é¢‘æ ¼å¼');
                    this.addSuggestion('å°è¯•æ›´æ–°æµè§ˆå™¨æˆ–ä½¿ç”¨å…¶ä»–æµè§ˆå™¨');
                }
            }

            bindRecordingTest() {
                const recordBtn = document.getElementById('recordBtn');
                const recordStatus = document.getElementById('recordStatus');

                recordBtn.addEventListener('click', async () => {
                    if (!this.isRecording) {
                        try {
                            this.log('å°è¯•è·å–éº¦å…‹é£æƒé™...');
                            recordStatus.textContent = 'æ­£åœ¨è·å–éº¦å…‹é£æƒé™...';
                            
                            const stream = await navigator.mediaDevices.getUserMedia({ 
                                audio: {
                                    echoCancellation: true,
                                    noiseSuppression: true,
                                    autoGainControl: true
                                } 
                            });

                            this.log('éº¦å…‹é£æƒé™è·å–æˆåŠŸ');
                            this.updateTestStatus('test-permission', 'pass', 'å·²æˆæƒ');
                            
                            // è·å–æ”¯æŒçš„MIMEç±»å‹
                            const mimeType = this.getBestMimeType();
                            const options = mimeType ? { mimeType } : {};
                            
                            this.mediaRecorder = new MediaRecorder(stream, options);
                            
                            this.mediaRecorder.ondataavailable = (event) => {
                                if (event.data.size > 0) {
                                    this.log(`å½•éŸ³æ•°æ®å—å¤§å°: ${event.data.size} bytes`);
                                }
                            };
                            
                            this.mediaRecorder.onstop = () => {
                                this.log('å½•éŸ³åœæ­¢');
                                stream.getTracks().forEach(track => track.stop());
                                recordBtn.textContent = 'ğŸ¤';
                                recordBtn.classList.remove('recording');
                                recordStatus.textContent = 'å½•éŸ³æµ‹è¯•å®Œæˆï¼åŠŸèƒ½æ­£å¸¸';
                                this.isRecording = false;
                            };
                            
                            this.mediaRecorder.onerror = (event) => {
                                this.log(`å½•éŸ³é”™è¯¯: ${event.error || 'æœªçŸ¥é”™è¯¯'}`);
                                recordStatus.textContent = 'å½•éŸ³è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯';
                            };
                            
                            this.mediaRecorder.start(1000);
                            this.isRecording = true;
                            recordBtn.textContent = 'â¹ï¸';
                            recordBtn.classList.add('recording');
                            recordStatus.textContent = 'æ­£åœ¨å½•éŸ³...ç‚¹å‡»åœæ­¢';
                            this.log('å¼€å§‹å½•éŸ³');
                            
                        } catch (error) {
                            this.log(`å½•éŸ³æµ‹è¯•å¤±è´¥: ${error.name} - ${error.message}`);
                            recordStatus.textContent = `å½•éŸ³å¤±è´¥: ${error.message}`;
                            
                            if (error.name === 'NotAllowedError') {
                                this.updateTestStatus('test-permission', 'fail', 'æƒé™è¢«æ‹’ç»');
                                this.addSuggestion('ç”¨æˆ·æ‹’ç»äº†éº¦å…‹é£æƒé™ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸');
                            } else if (error.name === 'NotFoundError') {
                                this.addSuggestion('æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡ï¼Œæ£€æŸ¥è®¾å¤‡è¿æ¥');
                            } else if (error.name === 'NotReadableError') {
                                this.addSuggestion('éº¦å…‹é£è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œå…³é—­å…¶ä»–éŸ³é¢‘åº”ç”¨');
                            }
                        }
                    } else {
                        // åœæ­¢å½•éŸ³
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.mediaRecorder.stop();
                        }
                    }
                });
            }

            getBestMimeType() {
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/mp4',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/wav'
                ];
                
                for (const type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }
                
                return '';
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹æµ‹è¯•
        document.addEventListener('DOMContentLoaded', () => {
            new RecordingTester();
        });
    </script>
</body>
</html> 